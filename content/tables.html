<!DOCTYPE html>
<!-- saved from url=(0014)about:internet -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Working with Tables</title>

<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 12px;
   margin: 8px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 { 
   font-size:2.2em; 
}

h2 { 
   font-size:1.8em; 
}

h3 { 
   font-size:1.4em; 
}

h4 { 
   font-size:1.0em; 
}

h5 { 
   font-size:0.9em; 
}

h6 { 
   font-size:0.8em; 
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre {	
   margin-top: 0;
   max-width: 95%;
   border: 1px solid #ccc;
   white-space: pre-wrap;
}

pre code {
   display: block; padding: 0.5em;
}

code.r, code.cpp {
   background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * { 
      background: transparent !important; 
      color: black !important; 
      filter:none !important; 
      -ms-filter: none !important; 
   }

   body { 
      font-size:12pt; 
      max-width:100%; 
   }
       
   a, a:visited { 
      text-decoration: underline; 
   }

   hr { 
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote { 
      padding-right: 1em; 
      page-break-inside: avoid; 
   }

   tr, img { 
      page-break-inside: avoid; 
   }

   img { 
      max-width: 100% !important; 
   }

   @page :left { 
      margin: 15mm 20mm 15mm 10mm; 
   }
     
   @page :right { 
      margin: 15mm 10mm 15mm 20mm; 
   }

   p, h2, h3 { 
      orphans: 3; widows: 3; 
   }

   h2, h3 { 
      page-break-after: avoid; 
   }
}

</style>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: rgb(88, 72, 246)
   }

   pre .number {
     color: rgb(0, 0, 205);
   }

   pre .comment {
     color: rgb(76, 136, 107);
   }

   pre .keyword {
     color: rgb(0, 0, 255);
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: rgb(3, 106, 7);
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>




</head>

<body>
<h1>Working with Tables</h1>

<p>R has great built-in support for working with data in tabular format.  Tables in R are called &ldquo;data frames.&rdquo;  By convention, response and annotation variables are arranged across the columns and observations down the rows.  Columns, and optionally rows, can also be given unique names.</p>

<h3>A note about table structure for Excel users</h3>

<p>Before we dive into loading and working with tabular data in R, it&#39;s worth taking a moment to consider a key difference between data formatting expectations in advanced statistical software packages like R and the bad habits most folks develop after years of working in Excel.  If you&#39;re used to working in other stats packages like SAS, SPSS or Minitab, you can skip this section.</p>

<p>Let&#39;s consider a simple example experimental design:  a response variable measured in two different treatment groups (A, B) over a 4 day period.  Excel has probably trained you to format the data something like this:</p>

<table><thead>
<tr>
<th>Day</th>
<th>Group A</th>
<th>Group B</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>5</td>
<td>5</td>
</tr>
<tr>
<td>2</td>
<td>6</td>
<td>7</td>
</tr>
<tr>
<td>3</td>
<td>7</td>
<td>9</td>
</tr>
<tr>
<td>4</td>
<td>8</td>
<td>11</td>
</tr>
</tbody></table>

<p>The reason we have all learned to format the data this way in Excel is that it makes it easy to produce plots &ndash; if we select these cells and click the scatter plot wizard, we&#39;ll get the desired plot with Day on the X-axis and two sets of points, one for Group A and the other Group B.</p>

<p>Statisticians, and by proxy statistical software packages, object to this formatting for an important reason.  The problem is that we&#39;ve mixed our concerns in designing the structure of these columns:  (1) <em>two</em> different columns contain values for the <em>same</em> response being measured; (2) a second variable in this design (treatment) has to be inferred from the column headings.  </p>

<p>The correct design would be a three column table, where each column describes <em>one and only one</em> variable in the experiment:</p>

<table><thead>
<tr>
<th>Day</th>
<th>Group</th>
<th>Response</th>
</tr>
</thead><tbody>
<tr>
<td>1</td>
<td>A</td>
<td>5</td>
</tr>
<tr>
<td>1</td>
<td>B</td>
<td>5</td>
</tr>
<tr>
<td>2</td>
<td>A</td>
<td>6</td>
</tr>
<tr>
<td>2</td>
<td>B</td>
<td>7</td>
</tr>
<tr>
<td>3</td>
<td>A</td>
<td>7</td>
</tr>
<tr>
<td>3</td>
<td>B</td>
<td>9</td>
</tr>
<tr>
<td>4</td>
<td>A</td>
<td>8</td>
</tr>
<tr>
<td>4</td>
<td>B</td>
<td>11</td>
</tr>
</tbody></table>

<p>If you have a lot of data formatted in the first of these two formats, don&#39;t worry.  Restructuring your tables is easy to do in R, as is generating any new categorical label columns you might need.  We can explore this topic in more detail if there&#39;s interest, but as a preview the tools you&#39;ll probably need are the <code>c(..., recursive = TRUE)</code> and <code>rep()</code> functions.</p>

<h3>Loading tabular data</h3>

<p>R can import tabular data from a wide variety of source file formats.  Base R has excellent support for loading data using the <code>read.table</code> family of functions.  There are also a wide array of R packages that support loading data from databases and other binary file formats.  If you just need to move data from an Excel worksheet into R, the easiest path is to save it as a text file (tab-delimited or csv) and load it into R using <code>read.table</code>. </p>

<p>If you&#39;re working in <a href="http://www.rstudio.com/">RStudio</a>, you can use the &ldquo;Import Dataset&rdquo; button on the Workspace tab to load data from a local file or over the web.  Under-the-hood RStudio is just calling <code>read.table</code> for you, which we&#39;ll explore below (see the History tab to find out what the command was that RStudio generated for you).</p>

<p>To follow along with this example, you can download the genetic code table and save it in your current working directory:  <a href="data/codons.txt">codons.txt</a>.  This table has two columns:  &ldquo;codon&rdquo; and &ldquo;aminoAcid.&rdquo;  To load the table into a variable:</p>

<pre><code>## [1] &quot;/home/gregg/r-club/content&quot;
</code></pre>

<pre><code class="r">codons &lt;- read.table(&quot;codons.txt&quot;, header = TRUE, stringsAsFactors = FALSE)
head(codons)
</code></pre>

<pre><code>##   codon aminoAcid
## 1   GCU         A
## 2   GCC         A
## 3   GCA         A
## 4   GCG         A
## 5   CGU         R
## 6   CGC         R
</code></pre>

<p>The <code>read.table</code> function takes a large number of optional arguments which allows it to adapt to a wide variety of different file formats.  Here we&#39;ve specified <code>header = TRUE</code> because the first line of our file contains column headings.  The <code>stringsAsFactors = FALSE</code> argument tells R not to try to convert text columns to a special type of data structure called a <code>factor</code>.  Factors are intended to flag strings as describing levels of a categorical variable.  They are a more advanced topic then we&#39;ll dive into here; so we&#39;ll turn them off.</p>

<h3>Accessing data in a data.frame</h3>

<p>Once your data is loaded into a data.frame (table), you can access vectors of data for individual variables in the table using the <code>$</code> syntax:</p>

<pre><code class="r">codons$codon
</code></pre>

<pre><code>##  [1] &quot;GCU&quot; &quot;GCC&quot; &quot;GCA&quot; &quot;GCG&quot; &quot;CGU&quot; &quot;CGC&quot; &quot;CGA&quot; &quot;CGG&quot; &quot;AGA&quot; &quot;AGG&quot; &quot;AAU&quot;
## [12] &quot;AAC&quot; &quot;GAU&quot; &quot;GAC&quot; &quot;UGU&quot; &quot;UGC&quot; &quot;CAA&quot; &quot;CAG&quot; &quot;GAA&quot; &quot;GAG&quot; &quot;GGU&quot; &quot;GGC&quot;
## [23] &quot;GGA&quot; &quot;GGG&quot; &quot;CAU&quot; &quot;CAC&quot; &quot;AUU&quot; &quot;AUC&quot; &quot;AUA&quot; &quot;AUG&quot; &quot;UUA&quot; &quot;UUG&quot; &quot;CUU&quot;
## [34] &quot;CUC&quot; &quot;CUA&quot; &quot;CUG&quot; &quot;AAA&quot; &quot;AAG&quot; &quot;UUU&quot; &quot;UUC&quot; &quot;CCU&quot; &quot;CCC&quot; &quot;CCA&quot; &quot;CCG&quot;
## [45] &quot;UCU&quot; &quot;UCC&quot; &quot;UCA&quot; &quot;UCG&quot; &quot;AGU&quot; &quot;AGC&quot; &quot;ACU&quot; &quot;ACC&quot; &quot;ACA&quot; &quot;ACG&quot; &quot;UGG&quot;
## [56] &quot;UAU&quot; &quot;UAC&quot; &quot;GUU&quot; &quot;GUC&quot; &quot;GUA&quot; &quot;GUG&quot; &quot;UAA&quot; &quot;UGA&quot; &quot;UAG&quot;
</code></pre>

<pre><code class="r">codons$aminoAcid
</code></pre>

<pre><code>##  [1] &quot;A&quot;    &quot;A&quot;    &quot;A&quot;    &quot;A&quot;    &quot;R&quot;    &quot;R&quot;    &quot;R&quot;    &quot;R&quot;    &quot;R&quot;    &quot;R&quot;   
## [11] &quot;N&quot;    &quot;N&quot;    &quot;D&quot;    &quot;D&quot;    &quot;C&quot;    &quot;C&quot;    &quot;Q&quot;    &quot;Q&quot;    &quot;E&quot;    &quot;E&quot;   
## [21] &quot;G&quot;    &quot;G&quot;    &quot;G&quot;    &quot;G&quot;    &quot;H&quot;    &quot;H&quot;    &quot;I&quot;    &quot;I&quot;    &quot;I&quot;    &quot;M&quot;   
## [31] &quot;L&quot;    &quot;L&quot;    &quot;L&quot;    &quot;L&quot;    &quot;L&quot;    &quot;L&quot;    &quot;K&quot;    &quot;K&quot;    &quot;F&quot;    &quot;F&quot;   
## [41] &quot;P&quot;    &quot;P&quot;    &quot;P&quot;    &quot;P&quot;    &quot;S&quot;    &quot;S&quot;    &quot;S&quot;    &quot;S&quot;    &quot;S&quot;    &quot;S&quot;   
## [51] &quot;T&quot;    &quot;T&quot;    &quot;T&quot;    &quot;T&quot;    &quot;W&quot;    &quot;Y&quot;    &quot;Y&quot;    &quot;V&quot;    &quot;V&quot;    &quot;V&quot;   
## [61] &quot;V&quot;    &quot;STOP&quot; &quot;STOP&quot; &quot;STOP&quot;
</code></pre>

<p>If we want to access a single data point we can use indexing syntax with <code>[]</code>.  When we are working with a 2D data structure, we can specific a <code>[row, col]</code>:</p>

<pre><code class="r">codons[1, 2]
</code></pre>

<pre><code>## [1] &quot;A&quot;
</code></pre>

<pre><code class="r">codons[2, 1]
</code></pre>

<pre><code>## [1] &quot;GCC&quot;
</code></pre>

<p>Let&#39;s explore indexing syntax in greater depth&hellip;</p>

<h3>Indexing syntax in R:  extracting &amp; replacing values</h3>

<p>Let&#39;s say we have a vector of numbers:</p>

<pre><code class="r">myNumbers &lt;- c(10, 20, 30, 40, 50)
</code></pre>

<p>We can extract elements from 1D vectors using the index syntax <code>[]</code> and integers:</p>

<pre><code class="r">myNumbers
</code></pre>

<pre><code>## [1] 10 20 30 40 50
</code></pre>

<pre><code class="r">myNumbers[1]
</code></pre>

<pre><code>## [1] 10
</code></pre>

<pre><code class="r">myNumbers[3]
</code></pre>

<pre><code>## [1] 30
</code></pre>

<p>Here, we&#39;ve extracted elements at the position given by the integer we put inside of the <code>[...]</code>.  Remember that the <code>1</code> and <code>3</code> are actually vectors of integers.  Of course this means we can also use integer vectors with more than one element inside of our index <code>[...]</code>&#39;s.  For example:</p>

<pre><code class="r">myNumbers[c(1, 3)]
</code></pre>

<pre><code>## [1] 10 30
</code></pre>

<p>You can use the <code>:</code> operator to easily create a sequence of numbers:</p>

<pre><code class="r"># The : operator creates a series of numbers
1:5
</code></pre>

<pre><code>## [1] 1 2 3 4 5
</code></pre>

<pre><code class="r">2:10
</code></pre>

<pre><code>## [1]  2  3  4  5  6  7  8  9 10
</code></pre>

<pre><code class="r"># We can use this inside of our [...]
myNumbers[2:3]
</code></pre>

<pre><code>## [1] 20 30
</code></pre>

<p>In addition to putting integer vectors inside of the index <code>[...]</code> we can also use logical vectors.  If we do, <code>TRUE</code> at a position causes a value to be extracted, while a <code>FALSE</code> indicates that it should be skipped.  Let&#39;s look at an example:</p>

<pre><code class="r">myNumbers
</code></pre>

<pre><code>## [1] 10 20 30 40 50
</code></pre>

<pre><code class="r">myNumbers[c(FALSE, TRUE, TRUE, TRUE, TRUE)]
</code></pre>

<pre><code>## [1] 20 30 40 50
</code></pre>

<pre><code class="r">myNumbers[c(TRUE, FALSE, FALSE, FALSE, FALSE)]
</code></pre>

<pre><code>## [1] 10
</code></pre>

<p>So why would you ever want to do this?  The answer lies in the combination of indexing and the logical operators (<code>&gt;</code>, <code>&lt;</code>, <code>==</code>, <code>!=</code>, and <code>%in%</code>).</p>

<p>With logical operators, you can ask if one vector of values or greater <code>&gt;</code> or less <code>&lt;</code> than another vector of values.  You can also ask if one vector of values is equal <code>==</code> or not equal <code>!=</code> to another.  Here are some examples:</p>

<pre><code class="r">myNumbers &gt; 25
</code></pre>

<pre><code>## [1] FALSE FALSE  TRUE  TRUE  TRUE
</code></pre>

<pre><code class="r">myNumbers &lt; 25
</code></pre>

<pre><code>## [1]  TRUE  TRUE FALSE FALSE FALSE
</code></pre>

<pre><code class="r"># Equality comparison uses == instead of =
myNumbers == 30
</code></pre>

<pre><code>## [1] FALSE FALSE  TRUE FALSE FALSE
</code></pre>

<pre><code class="r"># The `!` operator negates logical vectors (&#39;not&#39;)
myNumbers != 30
</code></pre>

<pre><code>## [1]  TRUE  TRUE FALSE  TRUE  TRUE
</code></pre>

<pre><code class="r">!(myNumbers &gt; 25)
</code></pre>

<pre><code>## [1]  TRUE  TRUE FALSE FALSE FALSE
</code></pre>

<p><strong>NOTE <code>=</code> vs <code>==</code>:</strong> Many beginers are confused by the difference between <code>=</code> and <code>==</code>.   The <code>=</code> operator is used for value assignment, traditionally for arguments inside of function calls such as <code>plot(x = 10, y = 1)</code>, or in newer versions of R in place of the <code>&lt;-</code> operator as in <code>a = 10</code>.  If you want to compare <em>equivalence</em> between two values you&#39;ll want to use the double <code>==</code> operator.  These operations will evaluate to a logical vector (<code>TRUE</code> or <code>FALSE</code>).</p>

<p>So how can we combine logical comparisons with indexing?  Here&#39;s an example, which is a very common idiom in R:</p>

<pre><code class="r">myNumbers[myNumbers &gt; 25]
</code></pre>

<pre><code>## [1] 30 40 50
</code></pre>

<pre><code class="r">myNumbers[myNumbers &lt; 25]
</code></pre>

<pre><code>## [1] 10 20
</code></pre>

<p>You can get fancy&hellip;</p>

<pre><code class="r">myNumbers[(myNumbers%%2) == 0]
</code></pre>

<pre><code>## [1] 10 20 30 40 50
</code></pre>

<p>What happened there?  If you need help figuring it out, look up the <code>%%</code> (<em>modulo</em>) operator on the help panel.</p>

<p>Finally, the indexing <code>[...]</code> syntax isn&#39;t just used to extract values from data structures.  It can also be used to assign values <em>into</em> existing structures.  For example:</p>

<pre><code class="r">myNumbers
</code></pre>

<pre><code>## [1] 10 20 30 40 50
</code></pre>

<pre><code class="r">myNumbers[3] &lt;- 100
myNumbers
</code></pre>

<pre><code>## [1]  10  20 100  40  50
</code></pre>

<pre><code class="r">myNumbers[2:3] &lt;- c(1, 2)
myNumbers
</code></pre>

<pre><code>## [1] 10  1  2 40 50
</code></pre>

<p>Now, back to our table&hellip;</p>

<h3>Calculating a new column</h3>

<p>We can use the <code>$</code> syntax (like the <code>[...]</code>) to assign data to existing columns on a <code>data.frame</code> or to create a new column.  Let&#39;s say that we want to add a new column to our <code>codons</code> table that will annotate what type of amino acid is encoded by each codon (non-polar, polar, acidic or basic).</p>

<p>We can start by creating a new column called <code>type</code> that contains all <code>NA</code> values:</p>

<pre><code class="r">codons$type &lt;- NA
head(codons)
</code></pre>

<pre><code>##   codon aminoAcid type
## 1   GCU         A   NA
## 2   GCC         A   NA
## 3   GCA         A   NA
## 4   GCG         A   NA
## 5   CGU         R   NA
## 6   CGC         R   NA
</code></pre>

<p>Here could have hand-encoded a vector of 20 strings describing the type of each amino acid in our table.  But we&#39;ll take the lazier path and learn a few new R tricks along the way.  Let&#39;s make some vectors that describe which amino acids belong to each of the four categories:</p>

<pre><code class="r"># Assuming physiological pH; we&#39;ll call histidine basic for simplicity!
nonpolar &lt;- c(&quot;A&quot;, &quot;C&quot;, &quot;G&quot;, &quot;I&quot;, &quot;L&quot;, &quot;M&quot;, &quot;F&quot;, &quot;P&quot;, &quot;W&quot;, &quot;V&quot;)
polar &lt;- c(&quot;N&quot;, &quot;Q&quot;, &quot;S&quot;, &quot;T&quot;, &quot;Y&quot;)
acidic &lt;- c(&quot;D&quot;, &quot;E&quot;)
basic &lt;- c(&quot;R&quot;, &quot;H&quot;, &quot;K&quot;)
# We can make sure we&#39;ve annotated all 20 amino acids
length(c(nonpolar, polar, acidic, basic)) == 20
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<p>Now we can update our <code>type</code> column using the annotations that we&#39;ve saved in these variables.  The logical <code>%in%</code> operator tests whether or not one vector of values (left side) is found in another (right side).  It returns a vector of boolean values of the same length as the left-hand test vector.  So we can do this:</p>

<pre><code class="r"># Which rows contain nonpolar amino acids?
codons$aminoAcid %in% nonpolar
</code></pre>

<pre><code>##  [1]  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [12] FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE
## [23]  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
## [34]  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
## [45] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE
## [56] FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE
</code></pre>

<pre><code class="r"># We can use these logical vectors to assign our type annotations
codons[codons$aminoAcid %in% nonpolar, &quot;type&quot;] &lt;- &quot;nonpolar&quot;
codons[codons$aminoAcid %in% polar, &quot;type&quot;] &lt;- &quot;polar&quot;
codons[codons$aminoAcid %in% acidic, &quot;type&quot;] &lt;- &quot;acidic&quot;
codons[codons$aminoAcid %in% basic, &quot;type&quot;] &lt;- &quot;basic&quot;
# Check to see if it worked...
head(codons)
</code></pre>

<pre><code>##   codon aminoAcid     type
## 1   GCU         A nonpolar
## 2   GCC         A nonpolar
## 3   GCA         A nonpolar
## 4   GCG         A nonpolar
## 5   CGU         R    basic
## 6   CGC         R    basic
</code></pre>

<p>Pretty neat, eh?  Working with numeric data in table columns is even more straight forward.  In R, it&#39;s very easy to create new columns that are calculated from exisiting data, as you might be used to doing in Excel.  In R, however, adding complex annotation columns like <code>type</code> above is also very simple.</p>

<p>Notice how we accomplished this task by composing a few minimal data structures, followed by a few relatively straight-forward assignments.  We never had to repeat assignment of any of our amino acid types.  In both software design and data analysis we always try to adhere to the &ldquo;<a href="http://en.wikipedia.org/wiki/Don&#x27;t_repeat_yourself">DRY</a>&rdquo; (don&#39;t repeat yourself) principle.  </p>

<p>This is much easier to do when working with tabular data in R than it is in traditional spreadsheet packages or other statistical environments.</p>

</body>

</html>

